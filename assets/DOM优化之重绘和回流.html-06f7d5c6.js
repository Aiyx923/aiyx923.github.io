import{_ as n,o as a,c as s,e as t}from"./app-00a966d3.js";const p={},e=t(`<h2 id="操作-dom-为什么这么慢" tabindex="-1"><a class="header-anchor" href="#操作-dom-为什么这么慢" aria-hidden="true">#</a> 操作 DOM 为什么这么慢？</h2><p>因为操作DOM要收<strong>过路费</strong>。</p><blockquote><p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p></blockquote><p>浏览器内核中的JS 引擎和渲染引擎是独立存在的，当我们用JS去操作DOM时，本质上是JS引擎和渲染引擎之间进行的“跨界交流”。</p><p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。</p><h2 id="回流和重绘" tabindex="-1"><a class="header-anchor" href="#回流和重绘" aria-hidden="true">#</a> 回流和重绘</h2><p>JS操作DOM很慢，而且修改DOM还会引发它的外观、样式、大小、位置的改变，就会触发<strong>重流</strong>或<strong>重绘</strong>。</p><ul><li><p>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p></li><li><p>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</p></li></ul><p>由此可以看出，重绘不一定导致回流，但是回流一定会导致重绘。</p><p>优化的关键，就是把重绘和回流的次数最小化。</p><h2 id="如何优化" tabindex="-1"><a class="header-anchor" href="#如何优化" aria-hidden="true">#</a> 如何优化</h2><p>知道了DOM慢的原因，我就可以逐步优化了。</p><h3 id="减少dom操作-将多次操作合并为一次。" tabindex="-1"><a class="header-anchor" href="#减少dom操作-将多次操作合并为一次。" aria-hidden="true">#</a> 减少DOM操作，将多次操作合并为一次。</h3><p>假如，我们要将1-1000渲染到<code>box</code>里，如下：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>box<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们首先想到的可能会这样：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;box&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">&lt;p&gt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;</span><span class="token template-punctuation string">\`</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然最终效果是可以实现的，但是每次for循环都要过一次“桥”，一次两次还好，如果操作几十万、几百万的数据呢？页面就会明显感到卡顿..</p><p>能不能优化呢？当然可以，我们可以先设置一个变量，先去操作这个变量，最后一次插入DOM。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;&#39;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    str <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">&lt;p&gt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;</span><span class="token template-punctuation string">\`</span></span>
<span class="token punctuation">}</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;box&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> str<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将多次DOM操作整合为一次，这也是一种优化的方式。</p><h3 id="使用documentfragment" tabindex="-1"><a class="header-anchor" href="#使用documentfragment" aria-hidden="true">#</a> 使用DocumentFragment</h3><p>将DOM多次修改，最后一次性插入到DOM中，这点在DocumentFragment中展现的淋漓尽致，关于DocumentFragment详细操作可以下一章。</p>`,23),o=[e];function c(i,l){return a(),s("div",null,o)}const u=n(p,[["render",c],["__file","DOM优化之重绘和回流.html.vue"]]);export{u as default};
