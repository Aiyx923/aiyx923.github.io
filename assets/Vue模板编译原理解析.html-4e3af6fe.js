import{_ as p,r as o,o as l,c,a as n,b as s,d as t,e}from"./app-00a966d3.js";const i={},r=e(`<h1 id="vue-模板编译原理解析" tabindex="-1"><a class="header-anchor" href="#vue-模板编译原理解析" aria-hidden="true">#</a> Vue 模板编译原理解析</h1><p>在 Vue 开发过程中，我们通常使用<code>.vue</code>文件进行开发，然后上线时打包成一个<code>js</code>最后在页面中加载然后渲染 DOM。</p><p>那么 他是怎么从<code>.vue</code> 文件编译成<code>.js</code> 的那，中间发生了什么？</p><p><img src="https://i.loli.net/2021/07/19/AWp6kCSvLth74Bj.png" alt="流程图"></p><h2 id="运行版本" tabindex="-1"><a class="header-anchor" href="#运行版本" aria-hidden="true">#</a> 运行版本</h2><p>通常我们利用 vue-cli 去初始化 Vue.js 时，在 Vue 中有两个版本：</p><ul><li><p>Runtime Only</p><ul><li><code>vue.js</code>： 完整版本，包含了模板编译的能力；<br> 我们在借助 vue-cli 生成的项目时，通常需要使用 webpack 的 vue-loader 工具，将<code>.vue</code>文件编译成<code>.js</code>文件，因为他是在编译阶段做的，所以只包含运行时的 Vue.js 代码，因此代码总量体积会比较轻。</li></ul></li><li><p>Runtime + Compiler</p><ul><li><code>vue.runtime.js</code>： 运行时版本，不提供模板编译能力，需要通过 vue-loader 进行提前编译。<br> 如果我们没有对代码做预编译的时候（如 CND 引入时）但又使用 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 需要编译器的版本</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">&quot;&lt;div&gt;{{ hi }}&lt;/div&gt;&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 这种情况不需要</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hi<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为在 Vue.js 中最终的渲染都是通过 render 函数，如果写 template 属性，则需要在编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。</p><h2 id="编译过程" tabindex="-1"><a class="header-anchor" href="#编译过程" aria-hidden="true">#</a> 编译过程</h2>`,10),u={href:"https://github1s.com/vuejs/vue/blob/HEAD/src/platforms/web/entry-runtime-with-compiler.js",target:"_blank",rel:"noopener noreferrer"},d=e(`<ul><li><p>解析器将模板字符串转换成 AST</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>优化语法树</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>生成最最终 <code>render</code> 函数代码字符串</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="解析器" tabindex="-1"><a class="header-anchor" href="#解析器" aria-hidden="true">#</a> 解析器</h3><p>编译过程首先是对模板进行解析，生成 element ASTs，他是一种抽象语法树，对于源代码的抽象语法结构的树状表现形式。</p><p>这个过程比较复杂，他会用到大量的正则表达式对字符串解析：</p><p>为了直观的演示<code>parse</code>的过程，我们看一个例子：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过 <code>parse</code> 后，生成的 AST 如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;div&quot;</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">staticRoot</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">plain</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">parent</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  <span class="token literal-property property">attrsList</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">attrsMap</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
      <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;p&quot;</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token literal-property property">staticRoot</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token literal-property property">plain</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token literal-property property">parent</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token literal-property property">attrsList</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token literal-property property">attrsMap</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
          <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
          <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;{{name}}&quot;</span><span class="token punctuation">,</span>
          <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
          <span class="token literal-property property">expression</span><span class="token operator">:</span> <span class="token string">&quot;_s(name)&quot;</span>
      <span class="token punctuation">}</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个过程是通过分析模板中的字符串，通过正则匹配（如<code>&lt;div&gt;</code>匹配<code>&lt;/div&gt;</code>）来生成的。</p><p>其实模板编译主要是两部分内容，一部分是截取字符串(span、p)，一部分是对截取之后的字符串做解析。</p>`,10),k={href:"https://leetcode-cn.com/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://ustbhuangyi.github.io/vue-analysis/v2/compile/parse.html#%E6%B5%81%E7%A8%8B%E5%9B%BE",target:"_blank",rel:"noopener noreferrer"},m=e(`<h3 id="优化器" tabindex="-1"><a class="header-anchor" href="#优化器" aria-hidden="true">#</a> 优化器</h3><p>优化器的目标是找出那些事静态节点并打上标记，而静态节点指的是 DOM 不需要发生改变的节点，如：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>我不会发生变化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>静态节点有两个好处：</p><ol><li>每次重新渲染的时候不需要再为静态节点创建新节点了</li><li>在 Virtual DOM 中的 patch 可以直接跳过（不会改变就没有必要 patch 了）</li></ol><p>优化器的实现原理主要分两部分</p><ol><li>第一步：用递归的方式将所有的节点添加<code>static</code>属性，标识是不是静态节点</li><li>第二步：标记所有的静态根节点</li></ol><p>什么是静态根节点？？</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>我是静态节点1，我不需要发生变化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>我是静态节点2，我不需要发生变化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ul 就是静态根节点。</p><p>做完了优化的过程之后，就会改每个 AST 树上的每一个元素打上标记<code>static</code>和<code>staticRoot</code>，这会运行时对模板的更新起到了极大的优化作用，会影响接下来执行代码生成的过程。</p>`,11),g={href:"https://ustbhuangyi.github.io/vue-analysis/v2/compile/optimize.htm",target:"_blank",rel:"noopener noreferrer"},h=e(`<h3 id="生成代码" tabindex="-1"><a class="header-anchor" href="#生成代码" aria-hidden="true">#</a> 生成代码</h3><p>代码生成器的作用是使用 <code>elemen ASTs</code> 生成 <code>render</code> 函数代码字符串。</p><p>如：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Berwin<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>c<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>模板生成后的 AST 后生成 render 后是这样的：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">with</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span>
    <span class="token string">&quot;p&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;Berwin&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token literal-property property">on</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">click</span><span class="token operator">:</span> c <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>_c</code>是<code>createElement</code>可以创建一个元素。</li><li><code>_v</code> 是<code>createTextVNode</code>的意思是创建一个文本节点。</li><li><code>_s</code> 是<code>toString</code>返回参数中的字符串。</li></ul><p>代码生成器的逻辑其实就是使用<code>element ASTs</code>去递归，然后拼出<code>_c(&#39;div&#39;,[_c(&#39;p&#39;,[_v(_s(name))])])</code>的字符串，最后传给<code>render</code></p><p>那如何拼出的这个字符串呢？</p><p>看下边的代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">genElement</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">el</span><span class="token operator">:</span> ASTElement<span class="token punctuation">,</span> <span class="token literal-property property">state</span><span class="token operator">:</span> CodegenState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> el<span class="token punctuation">.</span>plain <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> <span class="token function">genData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> children <span class="token operator">=</span> el<span class="token punctuation">.</span>inlineTemplate <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">_c(&#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>el<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>
    data <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// data</span>
  <span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>
    children <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>children<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// children</span>
  <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> code<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点是<code>code</code>的生成逻辑，<code>_c</code>（createElement）函数接受三个参数: <code>tabName</code>，<code>data</code>，<code>children</code>。</p><p>所以上面的逻辑就是用 genData 和 genChiildren 获取 data 和 children 然后拼到<code>_c</code>中，然后把拼好的<code>_c(tagName, data, children)</code>返回。</p><p>所以，两个问题：</p><ol><li>data 如何生成的(genData 的逻辑)</li><li>children 如何生成的（genChildren 逻辑）</li></ol><ul><li>genData 逻辑：主要靠判断不同的标签类别去生成不同的 data</li><li>genChildren 逻辑：递归加判断</li></ul><p>最后将生成的 code 装入 with 中。</p><p>至于为什么将代码放入<code>with(this){..}</code>中，其实是为了方便取值，先看它的使用方法：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;tom&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tom</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>with 的 优点： 当 with 传入的值非常复杂时，即当 object 为非常复杂的嵌套结构时，with 就使得代码显得非常简洁。</p></li><li><p>with 的缺点： js 的编译器会检测 with 块中的变量是否属于 with 传入的对象， 上述例子为例，js 会检测 a 和 b 是否属于 obj 对象，这样就会的导致 with 语句的执行速度大大下降，性能比较差。</p></li></ul><p>但是总体来看是优化了代码的结构，所以还是利大于弊的。</p>`,21),b={href:"https://ustbhuangyi.github.io/vue-analysis/v2/compile/codegen.html#generate",target:"_blank",rel:"noopener noreferrer"},y=e('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>从<code>.vue</code>文件是怎么编译为<code>.js</code>文件问题引出，到分析 Vue 模板的三个部分：解析器（parser）,优化器（optimalzer）和代码生成器（code generator）。</p><ul><li>解析器：将<code>模板字符串</code>转换成<code>element ASTs</code></li><li>优化器：将<code>ASTs</code> 打上标记，区分静态节点和静态根节点</li><li>代码生成器：将<code>ASTs</code>生成 <code>render</code> 函数代码</li><li>渲染：最后 <code>render</code> 会使用<code>createElement</code>可返回一个 VNode</li><li>VNode：在经过 <code>patch</code> 过程后生成真实的 DOM</li></ul><p><img src="https://i.loli.net/2021/07/20/wQ18raW7I3JytKu.png" alt=""></p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',5),_={href:"https://ustbhuangyi.github.io/vue-analysis/v2/prepare/build.html#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"},f={href:"https://vue-loader.vuejs.org/zh/guide/#vue-cli",target:"_blank",rel:"noopener noreferrer"},j={href:"https://juejin.cn/post/6863241580753616903",target:"_blank",rel:"noopener noreferrer"},w={href:"https://blog.csdn.net/wang729506596/article/details/90947583",target:"_blank",rel:"noopener noreferrer"},q={href:"https://juejin.cn/post/6844903576343412743",target:"_blank",rel:"noopener noreferrer"};function x(V,E){const a=o("ExternalLinkIcon");return l(),c("div",null,[r,n("p",null,[s("在 Vue 源码中编译过程这块"),n("a",u,[s("src/platforms/web/entry-runtime-with-compiler.js"),t(a)]),s("可以得出编译的三个过程：")]),d,n("p",null,[s("没截取一段标签的开头就 push 到栈中，解析到标签的结束就 pop 出来，当所有的字符串都截取没了也就解析完了（参考"),n("a",k,[s("leetCode"),t(a)]),s("）。")]),n("p",null,[s("这块挺复杂的，细节太多，参考："),n("a",v,[s("Vue.js 技术揭秘-parse"),t(a)])]),m,n("p",null,[s("详细的过程参考: "),n("a",g,[s("Vue.js 技术揭秘-optimize"),t(a)])]),h,n("p",null,[s("具体的参考:"),n("a",b,[s("Vue 技术揭秘-codeGen"),t(a)])]),y,n("ul",null,[n("li",null,[n("a",_,[s("Vue 技术揭秘"),t(a)])]),n("li",null,[n("a",f,[s("Vue loader"),t(a)])]),n("li",null,[n("a",j,[s("Vue 模板编译原理"),t(a)])]),n("li",null,[n("a",w,[s("vue 底层-template 模板编译"),t(a)])]),n("li",null,[n("a",q,[s("Vue 模板解析"),t(a)])])])])}const B=p(i,[["render",x],["__file","Vue模板编译原理解析.html.vue"]]);export{B as default};
